const request = require('supertest');
const express = require('express');
const mongoose = require('mongoose');
const https = require('https');
const config = require('./config');
const logger = require('./utils/logger');
const { mockDeep } = require('jest-mock-extended');

// Import the Express app
const app = require('./index');

// Mocking external dependencies
jest.mock('mongoose');
jest.mock('https');
jest.mock('./utils/logger');
jest.mock('bcryptjs', () => ({
  compare: jest.fn().mockResolvedValue(true),  // Mock bcryptjs
}));

// Sample test suite for index.js
describe('Express Server Tests', () => {

  // Test the root route
  it('should return API docs link on GET /', async () => {
    const res = await request(app).get('/');
    expect(res.statusCode).toEqual(200);
    expect(res.text).toContain('Laoag City One Stop Construction Permit Tracking ReST API Server');
  });

  // Test /users route
  it('should handle the /users route', async () => {
    const res = await request(app).get('/users');
    expect(res.statusCode).toEqual(404);  // Assuming no specific logic, just testing the route exists.
  });

  // Test /departments route
  it('should handle the /departments route', async () => {
    const res = await request(app).get('/departments');
    expect(res.statusCode).toEqual(404);  // Assuming no specific logic, just testing the route exists.
  });

  // Test if helmet middleware is applied (by checking the headers it sets)
  it('should have security headers set by helmet', async () => {
    const res = await request(app).get('/');
    expect(res.headers['x-dns-prefetch-control']).toEqual('off');
    expect(res.headers['x-frame-options']).toEqual('DENY');
    expect(res.headers['x-content-type-options']).toEqual('nosniff');
  });

  // Test MongoDB connection success
  it('should log successful MongoDB connection', async () => {
    mongoose.connect.mockResolvedValueOnce({});
    await app;
    expect(logger.info).toHaveBeenCalledWith('Connected to MongoDB');
  });

  // Test MongoDB connection failure
  it('should log error if MongoDB connection fails', async () => {
    const mockError = new Error('MongoDB connection failed');
    mongoose.connect.mockRejectedValueOnce(mockError);
    await app;  // Simulating the app start
    expect(logger.error).toHaveBeenCalledWith('Error connecting to MongoDB:', { message: mockError.message, stack: mockError.stack });
  });

  // Test HTTPS server setup in production
  it('should start HTTPS server in production', async () => {
    process.env.NODE_ENV = 'production';  // Simulate production environment
    https.createServer.mockReturnValueOnce({
      listen: jest.fn((port, callback) => callback()),  // Mock the listen function
    });
    await app;  // Simulating the app start in production
    expect(https.createServer).toHaveBeenCalled();
    expect(logger.info).toHaveBeenCalledWith(`Server is up and running on port ${config.port} with TLS`);
  });

  // Test HTTP server setup in development
  it('should start HTTP server in development', async () => {
    process.env.NODE_ENV = 'development';  // Simulate development environment
    const listenMock = jest.fn((port, callback) => callback());
    app.listen = listenMock;
    await app;
    expect(listenMock).toHaveBeenCalledWith(config.port, expect.any(Function));
    expect(logger.info).toHaveBeenCalledWith(`Server is up and running on port ${config.port}`);
  });
});
